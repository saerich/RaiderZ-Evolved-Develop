#include "StdAfx.h"
#include "GGameServerProfiler.h"

///////////////////////////////////////////////////////////////////////////////////////////////////
// AutoTestProfiler //////////

#pragma comment(lib, "winmm.lib")

DWORD GGameServerProfiler::GetNowTime()
{
	return timeGetTime();
}

GGameServerProfiler::GGameServerProfiler() 
: m_bEnabled(false)
, m_dwEnableTime(0)
, m_bRecordSampling(false)
{
	m_vecProfileImtems.resize(MAX_PROFILE_COUNT);
}


GGameServerProfiler::~GGameServerProfiler()
{
	if( m_bRecordSampling )
	{
		for(int i=0;i<MAX_PROFILE_COUNT;i++)
		{
			if (m_vecProfileImtems[i].arrayElapsedTimeData)
			{
				delete[] m_vecProfileImtems[i].arrayElapsedTimeData;
				m_vecProfileImtems[i].arrayElapsedTimeData = NULL;
			}
		}
		m_bRecordSampling = false;
	}
}

void GGameServerProfiler::Init(bool bEnabled, bool bRecord)
{
	m_bEnabled = bEnabled;
	m_bRecordSampling = bRecord;

	Reset();
}

void GGameServerProfiler::Reset()
{
	for(int i=0;i<MAX_PROFILE_COUNT;i++)
	{
		m_vecProfileImtems[i].szName[0]=0;
		m_vecProfileImtems[i].dwTotalTime=0;
		m_vecProfileImtems[i].dwMinTime = UINT_MAX;
		m_vecProfileImtems[i].dwMaxTime = 0;
		m_vecProfileImtems[i].dwCalledCount=0;

		if( m_bRecordSampling )
		{
			m_vecProfileImtems[i].arrayElapsedTimeData = new DWORD[ MAX_RECORD_SAMPLING ];
			m_vecProfileImtems[i].nElapsedTimeDataIndex = 0;
			m_vecProfileImtems[i].nElapsedTimeStandardDeviation = 0;
		}
		else
			m_vecProfileImtems[i].arrayElapsedTimeData = NULL;
	}

	m_dwEnableTime=GetNowTime();
	m_nMaxElapsedTimeDataIndex = 0;
}

void GGameServerProfiler::BeginProfile(int nIndex, const char* szName)
{
	if (!m_bEnabled) return;
	if (nIndex<0 || nIndex>=MAX_PROFILE_COUNT)
	{
		_ASSERTE(false && "프로파일링 Index 오류");
	}

	if(m_vecProfileImtems[nIndex].szName[0]==0)
	{
		strcpy_s(m_vecProfileImtems[nIndex].szName,szName);
	}

	m_vecProfileImtems[nIndex].dwStartTime=GetNowTime();
	m_vecProfileImtems[nIndex].dwCalledCount++;
}

void GGameServerProfiler::EndProfile(int nIndex)
{
	if (!m_bEnabled || nIndex<0 || nIndex>=MAX_PROFILE_COUNT) return;

	DWORD nNowTime = GetNowTime();
	DWORD nElapsedTime = nNowTime-m_vecProfileImtems[nIndex].dwStartTime;
	m_vecProfileImtems[nIndex].dwTotalTime+= nElapsedTime;

	if (nElapsedTime < m_vecProfileImtems[nIndex].dwMinTime) m_vecProfileImtems[nIndex].dwMinTime = nElapsedTime;
	if (nElapsedTime > m_vecProfileImtems[nIndex].dwMaxTime) m_vecProfileImtems[nIndex].dwMaxTime = nElapsedTime;

	if( m_bRecordSampling )
	{
		int& count = m_vecProfileImtems[ nIndex ].nElapsedTimeDataIndex;
		if( count < MAX_RECORD_SAMPLING )
		{
			_ASSERT( m_vecProfileImtems[ nIndex ].arrayElapsedTimeData != NULL && "레코드 가능하게 초기화 했는지 알아보세요");
			m_vecProfileImtems[ nIndex ].arrayElapsedTimeData[ count ] = nElapsedTime;
			count += 1;
		}
		m_nMaxElapsedTimeDataIndex = max(m_nMaxElapsedTimeDataIndex, count);
	}
}

void GGameServerProfiler::AddLineForAnalysis( int nIndex )
{
	if(m_vecProfileImtems[nIndex].szName[0]==0)
	{
		m_setLineWhenAnalysis.insert(nIndex);
	}
}

void GGameServerProfiler::FinalAnalysis(const char* filename)
{
	SaveSampling(filename);

	DWORD dwTotalTime = GetNowTime()-m_dwEnableTime;

	FILE *file=fopen(filename,"w+");

	fprintf(file," total time = %6.3f seconds \n",(float)dwTotalTime*0.001f);

	PutLine(file);
	fputs("  ID  |       Total        |   Count    |       Average      |         Min        |         Max        |    SD    | Scope\n", file);
	PutLine(file);

	for(int i=0;i<MAX_PROFILE_COUNT;i++)
	{
		if (m_setLineWhenAnalysis.find(i) != m_setLineWhenAnalysis.end())
		{
			PutLine(file);
		}

		if (m_vecProfileImtems[i].dwTotalTime<=0) continue;

		float fTotalTime = m_vecProfileImtems[i].dwTotalTime / 1000.0f;
		float fTotalTimePercent = min(m_vecProfileImtems[i].dwTotalTime * 100/(float)dwTotalTime, 100);
		DWORD nCount = m_vecProfileImtems[i].dwCalledCount;
		float fAverageTime = (m_vecProfileImtems[i].dwTotalTime/(float)nCount)/1000.0f;
		float fAverageTimePercent = min((m_vecProfileImtems[i].dwTotalTime*100/(float)nCount)/(float)dwTotalTime, 100);
		float fMinTime = m_vecProfileImtems[i].dwMinTime/1000.0f;
		float fMinTimePercent = min(m_vecProfileImtems[i].dwMinTime*100/(float)dwTotalTime, 100);
		float fMaxTime = m_vecProfileImtems[i].dwMaxTime/1000.0f;
		float fMaxTimePercent = min(m_vecProfileImtems[i].dwMaxTime*100/(float)dwTotalTime, 100);
		float fStandardDeviation = (float)m_vecProfileImtems[i].nElapsedTimeStandardDeviation;

		fprintf(file, " %4d | %8.3f (%6.2f%%) | %8d   | %8.3f (%6.2f%%) | %8.3f (%6.2f%%) | %8.3f (%6.2f%%) | %8.3f | %s\n",
			i,
			fTotalTime,
			fTotalTimePercent,
			nCount,
			fAverageTime,
			fAverageTimePercent,
			fMinTime,
			fMinTimePercent,
			fMaxTime,
			fMaxTimePercent,
			fStandardDeviation,
			m_vecProfileImtems[i].szName);
	}

	fputs("\nGenerated by AutoTestProfiler ", file);
	fputs("ⓒ 1998-2008, MAIET entertainment, Inc. all rights reserved.\n", file);

	fclose(file);

	return;


}

void GGameServerProfiler::PutLine( FILE * file )
{
	fputs("----------------------------------------------------------------------------------------------------------------------------------------\n", file);
}

void GGameServerProfiler::ResetSampling()
{
	if ( !m_bRecordSampling ) return;

	for(int i=0;i<MAX_PROFILE_COUNT;i++)
	{
		memset(m_vecProfileImtems[i].arrayElapsedTimeData, 0, sizeof(DWORD) * MAX_RECORD_SAMPLING);
		m_vecProfileImtems[i].nElapsedTimeDataIndex = 0;
	}
	m_nMaxElapsedTimeDataIndex = 0;
}

void GGameServerProfiler::SaveSampling( const char* filename )
{
	if( m_bRecordSampling )
	{
		char szSamplingFileName[_MAX_PATH];
		sprintf_s(szSamplingFileName, "%s.csv", filename);
		FILE* file=fopen(szSamplingFileName,"w");
		if (file == NULL) return;

		vector<MPROFILEITEM*> vecProfileItem;
		for(int i=0;i<MAX_PROFILE_COUNT;++i)
		{
			if (m_vecProfileImtems[i].dwTotalTime<=0) continue;
			vecProfileItem.push_back(&m_vecProfileImtems[i]);

			fprintf(file, "\"(%d)%s\",", i, m_vecProfileImtems[i].szName);
		}

		fprintf(file, "\n");

		// 표준 편차 계산
		for (size_t i = 0; i < vecProfileItem.size(); i++)
		{
			MPROFILEITEM* pItem = vecProfileItem[i];
			int nSamplingDataCount = pItem->nElapsedTimeDataIndex;
			if (nSamplingDataCount == 0) continue;

			double nAvg = 0;
			for (int j = 0; j < nSamplingDataCount; j++)
			{
				nAvg += pItem->arrayElapsedTimeData[j];
			}
			nAvg /= nSamplingDataCount;

			double sum = 0;
			for (int j = 0; j < nSamplingDataCount; j++)
			{
				sum += ((pItem->arrayElapsedTimeData[j] - nAvg) * (pItem->arrayElapsedTimeData[j] - nAvg));
				sum = sum / nSamplingDataCount;
			}
			pItem->nElapsedTimeStandardDeviation = sqrt(sum);
		}

		fprintf(file, "표준편차(값이 클수록 비균일적임)\n");
		for (size_t i = 0; i < vecProfileItem.size(); i++)
		{
			MPROFILEITEM* pItem = vecProfileItem[i];
			fprintf(file, "%.3f,", (float)pItem->nElapsedTimeStandardDeviation);
		}
		fprintf(file, "\n\n");

		for (int i = 0; i < MAX_RECORD_SAMPLING; i++)
		{
			if (i >= m_nMaxElapsedTimeDataIndex) break;

			for (size_t j = 0; j < vecProfileItem.size(); j++)
			{
				MPROFILEITEM* pItem = vecProfileItem[j];

				if (i < pItem->nElapsedTimeDataIndex)
				{
					fprintf(file, "%u,", pItem->arrayElapsedTimeData[i]);
				}
				else
				{
					fprintf(file, ",");
				}
			}
			fprintf(file, "\n");
		}
		fclose(file);
	}
}

DWORD GGameServerProfiler::GetTotalTimeByIndex(int nIndex)
{
	return m_vecProfileImtems[nIndex].dwTotalTime;
}

float GGameServerProfiler::GetFrameByIndex(int nIndex)
{
	if (0 == m_vecProfileImtems[nIndex].dwTotalTime) return 0.0f;

	return (float) m_vecProfileImtems[nIndex].dwCalledCount / ((float) m_vecProfileImtems[nIndex].dwTotalTime / 1000.0f);
}

